<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Submit a Song</title>
  <link rel="manifest" href="/api/manifest.json" />
  <link rel="stylesheet" href="/static/style.css" />
  <script defer src="/static/alpinejs-3.15.8.min.js"></script>
</head>
<body>
  <script src="/static/nav.js"></script>

  <div class="container" x-data="submitForm()">
    <h1>Add a Song</h1>
    <p class="subtitle">Share music with the family. It'll start playing within a few minutes.</p>

    <!-- Alerts -->
    <div x-show="successTrackId" class="alert success" x-cloak>
      Song submitted! Track ID: <code x-text="successTrackId"></code>
      <span x-show="pollStatus === 'ready'"> — Now in the queue ✓</span>
      <span x-show="pollStatus === 'pending' || pollStatus === 'processing'"> — Processing…</span>
      <span x-show="pollStatus === 'failed'" style="color: var(--danger)"> — Processing failed.</span>
    </div>

    <div x-show="warning" class="alert warning" x-cloak>
      ⚠️ <span x-text="warning"></span>
    </div>

    <div x-show="duplicates.length && !submitAnyway" class="alert warning" x-cloak>
      ⚠️ This song may already be in the library:
      <ul style="margin: 0.5rem 0 0.75rem; padding-left: 1.25rem;">
        <template x-for="d in duplicates" :key="d.id">
          <li x-text="`${d.title} by ${d.artist} (added by ${d.submitter})`"></li>
        </template>
      </ul>
      <div style="display:flex; gap:0.5rem; flex-wrap:wrap;">
        <button type="button" class="btn btn-sm" @click="submitAnyway = true; submitSong()">Submit anyway</button>
        <button type="button" class="btn btn-sm btn-secondary" @click="duplicates = []; submitAnyway = false">Cancel</button>
      </div>
    </div>

    <div x-show="errorMsg" class="alert error" x-cloak>
      <span x-text="errorMsg"></span>
    </div>

    <div class="card">
      <!-- Source tabs -->
      <div class="tabs">
        <button class="tab-btn" :class="{ active: tab === 'file' }" @click="tab = 'file'">Upload File</button>
        <button class="tab-btn" :class="{ active: tab === 'youtube' }" @click="tab = 'youtube'">YouTube</button>
      </div>

      <form @submit.prevent="submitSong">
        <div class="form-group">
          <label for="submitter">Your name</label>
          <input id="submitter" type="text" x-model="submitter"
                 list="submitter-names"
                 placeholder="e.g. Mom, Dad, Grandpa…" required />
          <datalist id="submitter-names">
            <template x-for="name in submitterNames" :key="name">
              <option :value="name"></option>
            </template>
          </datalist>
        </div>

        <!-- File upload -->
        <div x-show="tab === 'file'">
          <div class="form-group">
            <label for="fileInput">Audio file (MP3, WAV, FLAC, M4A, OGG — max 200MB)</label>
            <input id="fileInput" type="file" accept=".mp3,.wav,.flac,.m4a,.ogg,.opus"
                   @change="fileSelected($event)" />
          </div>
          <div class="form-group">
            <label for="titleInput">Title (optional — auto-detected from file name)</label>
            <input id="titleInput" type="text" x-model="title"
                   @input="title && scheduleDupCheck()"
                   placeholder="Song title" />
          </div>
          <div class="form-group">
            <label for="artistInput">Artist (optional)</label>
            <input id="artistInput" type="text" x-model="artist" placeholder="Artist name" />
          </div>
        </div>

        <!-- YouTube -->
        <div x-show="tab === 'youtube'">
          <div class="form-group">
            <label for="ytUrl">YouTube URL</label>
            <input id="ytUrl" type="url" x-model="youtubeUrl"
                   @input="scheduleDupCheck()"
                   placeholder="https://www.youtube.com/watch?v=…" />
          </div>
        </div>

        <div class="form-group">
          <label for="commentInput">Comment (optional — shown on the Now Playing page)</label>
          <textarea id="commentInput" x-model="comment" maxlength="280"
                    placeholder="A note for the family…" rows="2"></textarea>
        </div>

        <button type="submit" class="btn" :disabled="submitting">
          <span x-show="submitting" class="spinner"></span>
          <span x-text="submitting ? 'Submitting…' : 'Add to Station'"></span>
        </button>
      </form>
    </div>

    <!-- Status card after submission -->
    <div class="card" x-show="successTrackId" x-cloak>
      <h2>Submission Status</h2>
      <div class="track-item">
        <div class="track-meta">
          <div class="track-title" x-text="submittedTitle || 'Processing…'"></div>
          <div class="track-sub" x-text="submittedArtist"></div>
        </div>
        <span class="badge" :class="pollStatus" x-text="pollStatus"></span>
      </div>
      <p style="margin-top:1rem; color: var(--muted); font-size:0.875rem;">
        You can check <a href="/playing.html" style="color:var(--accent)">Now Playing</a> once it's ready.
      </p>
    </div>
  </div>

  <script>
    function submitForm() {
      return {
        tab: 'file',
        submitter: '',
        submitterNames: [],
        title: '',
        artist: '',
        comment: '',
        file: null,
        youtubeUrl: '',
        submitting: false,
        successTrackId: '',
        submittedTitle: '',
        submittedArtist: '',
        warning: '',
        errorMsg: '',
        pollStatus: 'pending',
        pollInterval: null,
        duplicates: [],
        duplicateChecked: false,
        submitAnyway: false,
        _dupCheckTimer: null,

        init() {
          fetch('/api/submitters')
            .then(r => r.json())
            .then(data => { this.submitterNames = data.submitters; })
            .catch(() => {});
        },

        fileSelected(event) {
          this.file = event.target.files[0];
        },

        extractVideoId(url) {
          try {
            const u = new URL(url);
            if (u.hostname === 'youtu.be') return u.pathname.slice(1).split('?')[0] || null;
            if (['youtube.com', 'www.youtube.com', 'm.youtube.com'].includes(u.hostname)) {
              return u.searchParams.get('v');
            }
          } catch { /* invalid URL */ }
          return null;
        },

        scheduleDupCheck() {
          clearTimeout(this._dupCheckTimer);
          this.duplicates = [];
          this.duplicateChecked = false;
          this.submitAnyway = false;
          this._dupCheckTimer = setTimeout(() => this.checkDuplicate(), 500);
        },

        async checkDuplicate() {
          const params = new URLSearchParams();
          if (this.tab === 'youtube' && this.youtubeUrl) {
            const vid = this.extractVideoId(this.youtubeUrl);
            if (vid) {
              params.set('video_id', vid);
              try {
                const oe = await fetch(`https://www.youtube.com/oembed?url=https://www.youtube.com/watch?v=${vid}&format=json`);
                if (oe.ok) {
                  const meta = await oe.json();
                  if (meta.title) params.set('title', meta.title);
                  if (meta.author_name) params.set('artist', meta.author_name);
                }
              } catch { /* oEmbed unavailable for this video */ }
            }
          }
          if (this.title) params.set('title', this.title);
          if (this.artist) params.set('artist', this.artist);
          if (!params.toString()) return;
          try {
            const res = await fetch(`/api/check-duplicate?${params}`);
            const data = await res.json();
            this.duplicates = data.matches;
          } catch { /* ignore network errors during check */ }
          this.duplicateChecked = true;
        },

        async submitSong() {
          this.errorMsg = '';
          this.warning = '';
          this.successTrackId = '';

          if (!this.submitter.trim()) {
            this.errorMsg = 'Please enter your name.';
            return;
          }

          // If the debounce hasn't fired yet or the fetch hasn't returned, run the check now
          if (!this.duplicateChecked) {
            clearTimeout(this._dupCheckTimer);
            this._dupCheckTimer = null;
            await this.checkDuplicate();
          }

          if (this.duplicates.length > 0 && !this.submitAnyway) {
            // Warning UI is shown via x-show — don't proceed
            return;
          }

          this.submitting = true;
          const fd = new FormData();
          fd.append('submitter', this.submitter.trim());

          if (this.tab === 'file') {
            if (!this.file) { this.errorMsg = 'Please select a file.'; this.submitting = false; return; }
            fd.append('file', this.file);
            if (this.title) fd.append('title', this.title);
            if (this.artist) fd.append('artist', this.artist);
          } else if (this.tab === 'youtube') {
            if (!this.youtubeUrl) { this.errorMsg = 'Please enter a YouTube URL.'; this.submitting = false; return; }
            fd.append('youtube_url', this.youtubeUrl);
          }
          if (this.comment.trim()) fd.append('comment', this.comment.trim());

          try {
            const res = await fetch('/api/submit', { method: 'POST', body: fd });
            const data = await res.json();
            if (!res.ok) {
              if (res.status === 429) {
                this.warning = data.detail;
              } else {
                this.errorMsg = data.detail || 'Submission failed.';
              }
              return;
            }
            this.successTrackId = data.track_id;
            if (data.warning) this.warning = data.warning;
            this.youtubeUrl = '';
            this.file = null;
            this.title = '';
            this.artist = '';
            this.comment = '';
            this.duplicates = [];
            this.duplicateChecked = false;
            this.submitAnyway = false;
            document.getElementById('fileInput').value = '';
            this.pollStatus = 'pending';
            this.startPolling(data.track_id);
          } catch (e) {
            this.errorMsg = 'Network error. Please try again.';
          } finally {
            this.submitting = false;
          }
        },

        startPolling(trackId) {
          this.pollInterval = setInterval(async () => {
            try {
              const res = await fetch(`/api/track/${trackId}`);
              const data = await res.json();
              this.pollStatus = data.status;
              this.submittedTitle = data.title;
              this.submittedArtist = data.artist;
              if (data.status === 'ready' || data.status === 'failed') {
                clearInterval(this.pollInterval);
                if (data.status === 'failed' && data.error_msg) {
                  this.warning = 'Processing failed: ' + data.error_msg;
                }
              }
            } catch (e) {
              // ignore transient errors during polling
            }
          }, 5000);
        }
      };
    }
  </script>
</body>
</html>
