<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Now Playing</title>
  <link rel="manifest" href="/api/manifest.json" />
  <link rel="apple-touch-icon" href="/static/apple-touch-icon.png" />
  <link rel="icon" type="image/png" href="/static/favicon.png" />
  <link rel="stylesheet" href="/static/style.css" />
  <script src="/static/push.js"></script>
  <script defer src="/static/alpinejs-3.15.8.min.js"></script>
</head>
<body>
  <script src="/static/nav.js"></script>

  <div class="container" x-data="playerPage()" x-init="init()">
    <h1>Now Playing</h1>

    <!-- Player -->
    <div class="card">
      <audio x-ref="audio" preload="auto"></audio>

      <div style="display:flex; align-items:center; gap:0.75rem;">
        <button class="btn" style="font-size:1.1rem; flex:1;" @click="togglePlay()" :disabled="loading">
          <span x-show="loading" class="spinner"></span>
          <span x-text="loading ? 'Connectingâ€¦' : (playing ? 'â¸ Pause' : (everPlayed ? 'â–¶ Resume from Live' : 'â–¶ Play'))"></span>
        </button>

        <span x-show="playing" class="live-indicator" x-cloak>
          <span class="live-dot"></span> LIVE
        </span>

        <button x-show="airplayAvailable" @click="airPlay()" x-cloak
                class="btn secondary" style="font-size:0.875rem; flex-shrink:0;">
          AirPlay
        </button>

        <button x-show="castAvailable || casting" @click="cast()" x-cloak
                class="btn" :class="casting ? '' : 'secondary'"
                style="padding:0.5rem 0.6rem; flex-shrink:0;"
                :aria-label="casting ? 'Stop casting' : 'Cast to device'">
          <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
            <path d="M21 3H3c-1.1 0-2 .9-2 2v3h2V5h18v14h-7v2h7c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zM1 18v3h3c0-1.66-1.34-3-3-3zm0-4v2c2.76 0 5 2.24 5 5h2c0-3.87-3.13-7-7-7zm0-4v2c4.97 0 9 4.03 9 9h2c0-6.08-4.93-11-11-11z"/>
          </svg>
        </button>
      </div>

      <div x-show="!isIos" style="display:flex; align-items:center; gap:0.4rem; margin-top:0.75rem;">
        <span style="opacity:0.5; font-size:0.9rem; line-height:1;">ðŸ”ˆ</span>
        <input type="range" min="0" max="1" step="0.05" x-model="volume" @input="setVolume()" style="flex:1; cursor:pointer;" />
        <span style="opacity:0.5; font-size:0.9rem; line-height:1;">ðŸ”Š</span>
      </div>
    </div>

    <!-- Now Playing Info -->
    <div x-show="nowPlaying" class="now-playing" x-cloak>
      <div class="label">â™ª On Air</div>
      <div class="title" x-text="nowPlaying?.title"></div>
      <div class="artist" x-text="nowPlaying?.artist"></div>
      <div style="margin-top:0.5rem; font-size:0.8rem; color: var(--muted);">
        Submitted by <strong x-text="nowPlaying?.submitter"></strong>
      </div>
      <div x-show="nowPlaying?.comment" style="margin-top:0.4rem; font-size:0.9rem; color: var(--muted); font-style:italic;"
           x-text="nowPlaying?.comment"></div>
    </div>

    <div x-show="!nowPlaying && loaded" class="now-playing" x-cloak>
      <div class="label">Station</div>
      <div class="title">Starting upâ€¦</div>
      <div class="artist" style="color:var(--muted)">Nothing playing yet. Submit a song!</div>
    </div>

    <!-- Push notifications -->
    <div class="card" x-show="pushSupported" x-cloak>
      <h2>Notifications</h2>
      <p style="color:var(--muted); font-size:0.875rem; margin-bottom:0.75rem;">
        Get notified when a family member adds a new song.
      </p>

      <div x-show="pushNeedsInstall === 'ios'" style="color:var(--muted); font-size:0.875rem;">
        To enable notifications on iOS, tap <strong>Share â†’ Add to Home Screen</strong> first,
        then open the app from your home screen and come back here.
      </div>

      <div x-show="pushNeedsInstall !== 'ios'">
        <button class="btn" :class="pushSubscribed ? 'btn-secondary' : ''"
                :disabled="pushBusy"
                @click="togglePush()">
          <span x-show="pushBusy" class="spinner"></span>
          <span x-text="pushSubscribed ? 'Turn off notifications' : 'Turn on notifications'"></span>
        </button>
        <div x-show="pushError" class="alert error" x-cloak style="margin-top:0.5rem;"
             x-text="pushError"></div>
      </div>
    </div>

    <!-- Pending count -->
    <div x-show="pendingCount > 0" class="alert warning" x-cloak>
      <span x-text="pendingCount"></span> song(s) processing in the background.
    </div>

    <!-- Recent Tracks -->
    <div class="card" x-show="recent.length > 0" x-cloak>
      <h2>Recently Played</h2>
      <template x-for="track in recent" :key="track.played_at">
        <div class="track-item">
          <div class="track-meta">
            <div class="track-title" x-text="track.title"></div>
            <div class="track-sub">
              <span x-text="track.artist"></span> Â· by <span x-text="track.submitter"></span>
              Â· <span x-text="timeAgo(track.played_at)"></span>
            </div>
          </div>
        </div>
      </template>
    </div>

    <div x-show="recent.length === 0 && loaded" class="empty-state" x-cloak>
      No play history yet.
    </div>
  </div>

  <script>
    function playerPage() {
      // Use the cached token URL immediately (populated by refresh() on first visit)
      // so session restore and init() never race against the status fetch.
      const _cachedPublicStream = localStorage.getItem('radioPublicStreamUrl') || '';
      return {
        nowPlaying: null,
        recent: [],
        pendingCount: 0,
        loaded: false,
        playing: false,
        loading: false,
        everPlayed: false,
        userPaused: false,
        volume: 1,
        isIos: /iphone|ipad|ipod/i.test(navigator.userAgent),
        airplayAvailable: false,
        castAvailable: false,
        casting: false,
        streamUrl: _cachedPublicStream || `${location.protocol}//${location.hostname}/stream`,
        publicStreamUrl: _cachedPublicStream,
        pushSupported: false,
        pushNeedsInstall: false,
        pushSubscribed: false,
        pushBusy: false,
        pushError: '',

        async init() {
          const audio = this.$refs.audio;
          audio.volume = this.volume;
          audio.src = this.streamUrl;

          audio.addEventListener('play', () => {
            this.everPlayed = true;
            sessionStorage.setItem('radioState', JSON.stringify({ active: true, paused: false }));
          });

          audio.addEventListener('playing', () => {
            this.playing = true;
            this.loading = false;
            if ('mediaSession' in navigator) navigator.mediaSession.playbackState = 'playing';
          });

          audio.addEventListener('waiting', () => {
            this.loading = true;
          });

          audio.addEventListener('pause', () => {
            this.playing = false;
            this.loading = false;
            if (this.userPaused) {
              sessionStorage.setItem('radioState', JSON.stringify({ active: true, paused: true }));
            }
            this.userPaused = false;
            if ('mediaSession' in navigator) navigator.mediaSession.playbackState = 'paused';
          });

          audio.addEventListener('error', () => {
            this.playing = false;
            this.loading = false;
          });

          // Restore play state when navigating back from another page
          const saved = JSON.parse(sessionStorage.getItem('radioState') || 'null');
          if (saved && saved.active) {
            this.everPlayed = true;
            if (!saved.paused) {
              this.loading = true;
              audio.src = `${this.streamUrl}?t=${Date.now()}`;
              audio.play().catch(() => { this.loading = false; });
            }
          }

          // AirPlay (iOS Safari only)
          this.airplayAvailable = typeof audio.webkitShowPlaybackTargetPicker === 'function';

          // Remote Playback API â€” Cast to Chromecast / other devices (Chrome)
          if ('remote' in audio) {
            audio.remote.watchAvailability((available) => {
              this.castAvailable = available;
            }).catch(() => {});
            audio.remote.addEventListener('disconnect', () => {
              this.casting = false;
            });
          }

          // Media Session API (Android lock screen / notification controls)
          if ('mediaSession' in navigator) {
            navigator.mediaSession.setActionHandler('play', () => { if (!this.playing && !this.casting) this.togglePlay(); });
            navigator.mediaSession.setActionHandler('pause', () => { if (this.playing && !this.casting) this.togglePlay(); });
            navigator.mediaSession.setActionHandler('stop', () => { if (this.playing && !this.casting) this.togglePlay(); });
          }

          await this.refresh();
          setInterval(() => this.refresh(), 15000);

          // Push notification state
          const ph = window.pushHelpers;
          if (ph && ph.isSupported()) {
            this.pushSupported = true;
            this.pushNeedsInstall = ph.needsInstall();
            this.pushSubscribed = await ph.isSubscribed();
          }
        },

        togglePlay() {
          const audio = this.$refs.audio;
          if (this.playing) {
            this.userPaused = true;
            audio.pause();
          } else {
            this.loading = true;
            if (this.everPlayed) {
              // Resume: reconnect to get current live point, discarding buffered audio
              audio.src = `${this.publicStreamUrl || this.streamUrl}?t=${Date.now()}`;
            }
            audio.play().catch(() => { this.loading = false; });
          }
        },

        setVolume() {
          this.$refs.audio.volume = this.volume;
        },

        airPlay() {
          this.$refs.audio.webkitShowPlaybackTargetPicker();
        },

        async cast() {
          const audio = this.$refs.audio;
          // If already casting, re-open the picker so the user can disconnect
          if (this.casting) {
            audio.remote.prompt().catch(() => {});
            return;
          }
          if (!this.publicStreamUrl) {
            // Token stream not configured â€” cast directly; will likely 401 on Chromecast
            audio.remote.prompt().catch(() => {});
            return;
          }
          // Switch to unauthenticated token URL so the Cast device can fetch the stream
          const wasPlaying = this.playing;
          audio.src = this.publicStreamUrl;
          if (wasPlaying) audio.play().catch(() => {});
          try {
            await audio.remote.prompt();
            this.casting = true;
          } catch (e) {
            // User cancelled â€” restore the original authenticated URL
            this.casting = false;
            this.loading = wasPlaying;
            audio.src = wasPlaying ? `${this.streamUrl}?t=${Date.now()}` : this.streamUrl;
            if (wasPlaying) audio.play().catch(() => { this.loading = false; });
          }
        },

        async refresh() {
          try {
            const res = await fetch('/api/status');
            const data = await res.json();
            this.nowPlaying = data.now_playing;
            this.recent = data.recent;
            this.pendingCount = data.pending_count;
            this.loaded = true;
            if (data.public_stream_url) {
              const tokenUrl = `${location.protocol}//${location.hostname}${data.public_stream_url}`;
              localStorage.setItem('radioPublicStreamUrl', tokenUrl);
              if (!this.publicStreamUrl) {
                this.publicStreamUrl = tokenUrl;
                this.streamUrl = tokenUrl;
              }
            } else {
              // Token removed from server â€” clear the cache
              localStorage.removeItem('radioPublicStreamUrl');
            }
            if ('mediaSession' in navigator && this.nowPlaying) {
              navigator.mediaSession.metadata = new MediaMetadata({
                title: this.nowPlaying.title,
                artist: this.nowPlaying.artist,
                artwork: [
                  { src: `${location.origin}/static/icon-192.png`, sizes: '192x192', type: 'image/png' },
                  { src: `${location.origin}/static/icon-512.png`, sizes: '512x512', type: 'image/png' },
                ],
              });
            }
          } catch (e) {
            console.error('Status fetch failed', e);
          }
        },

        async togglePush() {
          this.pushBusy = true;
          this.pushError = '';
          try {
            if (this.pushSubscribed) {
              await window.pushHelpers.unsubscribe();
              this.pushSubscribed = false;
            } else {
              await window.pushHelpers.subscribe();
              this.pushSubscribed = true;
            }
          } catch (e) {
            this.pushError = e.message || 'Something went wrong. Please try again.';
          } finally {
            this.pushBusy = false;
          }
        },

        timeAgo(isoStr) {
          const diff = (Date.now() - new Date(isoStr)) / 1000;
          if (diff < 60) return 'just now';
          if (diff < 3600) return `${Math.round(diff / 60)}m ago`;
          if (diff < 86400) return `${Math.round(diff / 3600)}h ago`;
          return `${Math.round(diff / 86400)}d ago`;
        }
      };
    }
  </script>
</body>
</html>
